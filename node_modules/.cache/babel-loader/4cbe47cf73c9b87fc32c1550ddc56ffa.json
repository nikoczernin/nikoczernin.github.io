{"ast":null,"code":"//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport StartRound from './StartRound.vue';\nimport StartGuessing from './StartGuessing';\nimport Guessing from './Guessing';\nimport EndGuessing from './EndGuessing';\nimport EndRound from './EndRound';\nimport GameOver from './GameOver';\nexport default {\n  props: {\n    recentGame: Object\n  },\n\n  data() {\n    return {\n      state: 'startRound',\n      team1: [],\n      team2: [],\n      // keep an index of the player who is explaining atm\n      team1Index: 0,\n      team2Index: 0,\n      currentTurnTeam: 1,\n      // which team is playing rn?\n      currentTermIndex: 0,\n      pointsGained: 0,\n      currentRound: 0,\n      // pantomime or whatever\n      terms: [],\n      // this terms array gets reloaded every round\n      timeToGuessSetting: 5,\n      timeToGuess: null,\n      // timer \n      timePentaltyAmount: 10,\n      scores: {\n        team1: 0,\n        team2: 0\n      } // one point per term\n\n    };\n  },\n\n  components: {\n    StartRound,\n    StartGuessing,\n    Guessing,\n    EndGuessing,\n    EndRound,\n    GameOver\n  },\n  watch: {\n    timeToGuess() {\n      if (this.timeToGuess <= 0) {\n        this.endGuessing();\n      }\n    }\n\n  },\n  methods: {\n    getTermsArray() {\n      this.terms = []; // make it empty first\n\n      for (let id in this.recentGame.setup.terms) {\n        this.terms.push(this.recentGame.setup.terms[id][0]);\n      }\n    },\n\n    startRound() {\n      this.state = 'startGuessing';\n      this.currentTermIndex = 0; // start with the first term\n      // get the terms array\n\n      this.getTermsArray(); // randomize the terms array\n\n      this.shuffleArray(this.terms);\n    },\n\n    startGuessing() {\n      this.state = \"guessing\";\n      this.pointsGained = 0;\n      this.timeToGuess = this.timeToGuessSetting; // start the timer\n\n      this.interval = setInterval(() => this.timeToGuess--, 1000);\n    },\n\n    shuffleArray(arr) {\n      arr.sort(() => Math.random() - 0.5);\n    },\n\n    timePentalty(team) {\n      this.timeToGuess = this.timeToGuess - 10;\n    },\n\n    //term returned\n    termPassed() {\n      this.timePentalty();\n      this.terms.push(this.terms[this.currentTermIndex]); // keep the term to play it again\n\n      this.currentTermIndex++; // if this was the last term in the terms array, end the guessing\n\n      if (this.currentTermIndex == this.terms.length) {\n        this.endGuessing();\n      }\n    },\n\n    termGuessed() {\n      this.pointsGained++; // reward\n\n      this.currentTermIndex++;\n\n      if (this.currentTermIndex == this.terms.length) {\n        this.endGuessing();\n      }\n    },\n\n    endGuessing() {\n      this.state = \"endGuessing\";\n      clearInterval(this.interval); // stop the timer\n\n      this.scores[\"team\" + this.currentTurnTeam] = this.scores[\"team\" + this.currentTurnTeam] + this.pointsGained; // log the game's new progress\n\n      let newInfo = {\n        \"round\": this.currentRound,\n        \"team\": this.currentTurnTeam,\n        \"points\": this.pointsGained\n      };\n      this.$emit('addToProgress', newInfo);\n    },\n\n    // increment the teamIndex so that the next person can play\n    nextPlayersTurn() {\n      if (this.currentTurnTeam - 1) {\n        this.team2Index = (this.team2Index + 1) % this.team2.length;\n      } else {\n        this.team1Index = (this.team1Index + 1) % this.team1.length;\n      }\n    },\n\n    nextTeamsTurn() {\n      if (this.currentTurnTeam - 1) {\n        this.currentTurnTeam = 1;\n      } else {\n        this.currentTurnTeam = 2;\n      }\n    },\n\n    turnOver() {\n      this.nextPlayersTurn();\n      this.nextTeamsTurn(); // round not over, some terms are not guessed yet\n\n      if (this.currentTermIndex < this.terms.length) {\n        this.state = 'startGuessing';\n      } // round is over\n      else {\n        this.state = 'endRound';\n      }\n    },\n\n    endRound() {\n      // check if there are still rounds to be played\n      while (this.currentRound + 1 < this.recentGame.setup.rules.rounds.length) {\n        this.currentRound++;\n\n        if (this.recentGame.setup.rules.rounds[this.currentRound].value) {\n          this.state = 'startRound';\n          return;\n        }\n      }\n\n      this.gameOver();\n    },\n\n    gameOver() {\n      this.$emit('gameOver'); // delete this\n\n      this.state = 'gameOver';\n    }\n\n  },\n\n  mounted() {\n    // distribute the teams now\n    for (let id in this.recentGame.setup.playersTeams) {\n      let name = this.recentGame.setup.playersTeams[id].name;\n      let team = this.recentGame.setup.playersTeams[id].team;\n\n      if (team == 1) {\n        this.team1.push(name);\n      } else if (team == 2) {\n        this.team2.push(name);\n      } else {\n        console.log('oida');\n      }\n    } // the first round should be a selected one\n\n\n    for (let i = 0; i < this.recentGame.setup.rules.rounds.length; i++) {\n      if (this.recentGame.setup.rules.rounds[i].value) {\n        this.currentRound = i;\n        break;\n      }\n    }\n  }\n\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4DA;AACA;AACA;AACA;AACA;AACA;AAEA;EACAA;IACAC;EADA,CADA;;EAIAC;IACA;MACAC,mBADA;MAGAC,SAHA;MAIAC,SAJA;MAKA;MACAC,aANA;MAOAC,aAPA;MASAC,kBATA;MASA;MACAC,mBAVA;MAWAC,eAXA;MAaAC,eAbA;MAaA;MAEAC,SAfA;MAeA;MAEAC,qBAjBA;MAkBAC,iBAlBA;MAkBA;MACAC,sBAnBA;MAqBAC;QAAAZ;QAAAC;MAAA,CArBA,CAqBA;;IArBA;EAwBA,CA7BA;;EA8BAY;IACAC,UADA;IAEAC,aAFA;IAGAC,QAHA;IAIAC,WAJA;IAKAC,QALA;IAMAC;EANA,CA9BA;EAuCAC;IACAV;MACA;QACA;MACA;IACA;;EALA,CAvCA;EA+CAW;IACAC;MACA,gBADA,CACA;;MACA;QACA;MACA;IAEA,CAPA;;IASAC;MACA;MACA,0BAFA,CAEA;MACA;;MACA,qBAJA,CAKA;;MACA;IAEA,CAjBA;;IAkBAC;MACA;MACA;MAEA,2CAJA,CAOA;;MACA;IACA,CA3BA;;IA6BAC;MACAC;IACA,CA/BA;;IAiCAC;MACA;IACA,CAnCA;;IAqCA;IACAC;MACA;MACA,mDAFA,CAEA;;MACA,wBAHA,CAIA;;MACA;QACA;MACA;IACA,CA9CA;;IA+CAC;MACA,oBADA,CACA;;MACA;;MACA;QACA;MACA;IACA,CArDA;;IAuDAC;MACA;MACAC,6BAFA,CAEA;;MACA,4GAHA,CAKA;;MACA;QACA,0BADA;QAEA,4BAFA;QAGA;MAHA;MAKA;IACA,CAnEA;;IAqEA;IACAC;MACA;QACA;MACA,CAFA,MAEA;QACA;MACA;IACA,CA5EA;;IA8EAC;MACA;QAAA;MAAA,OACA;QAAA;MAAA;IACA,CAjFA;;IAmFAC;MACA;MACA,qBAFA,CAGA;;MACA;QACA;MACA,CAFA,CAGA;MAHA,KAIA;QACA;MACA;IAEA,CA/FA;;IAiGAC;MACA;MACA;QACA;;QACA;UACA;UACA;QACA;MACA;;MACA;IACA,CA3GA;;IA6GAC;MACA,uBADA,CACA;;MACA;IACA;;EAhHA,CA/CA;;EAkKAC;IACA;IACA;MACA;MACA;;MACA;QAAA;MAAA,OACA;QAAA;MAAA,OACA;QAAAC;MAAA;IACA,CARA,CAUA;;;IACA;MACA;QACA;QACA;MACA;IACA;EAEA;;AApLA","names":["props","recentGame","data","state","team1","team2","team1Index","team2Index","currentTurnTeam","currentTermIndex","pointsGained","currentRound","terms","timeToGuessSetting","timeToGuess","timePentaltyAmount","scores","components","StartRound","StartGuessing","Guessing","EndGuessing","EndRound","GameOver","watch","methods","getTermsArray","startRound","startGuessing","shuffleArray","arr","timePentalty","termPassed","termGuessed","endGuessing","clearInterval","nextPlayersTurn","nextTeamsTurn","turnOver","endRound","gameOver","mounted","console"],"sourceRoot":"src/components/games/charades/play","sources":["CharadesPlay.vue"],"sourcesContent":["<template>\n    <div>   \n        <StartRound \n            :currentRound=\"recentGame.setup.rules.rounds[currentRound]\"\n            @startRound=\"startRound\"\n            v-if=\"state=='startRound'\"\n        \n        />\n        <StartGuessing\n            :currentTurnTeam=\"currentTurnTeam\"\n            :currentPlayer=\"currentTurnTeam == 1 ? team1[team1Index] : team2[team2Index]\"\n            :currentRoundDescription=\"recentGame.setup.rules.rounds[currentRound].explanation\"\n            @startGuessing=\"startGuessing\"\n            v-if=\"state=='startGuessing'\"\n        />\n                \n        <Guessing\n            :currentTurnTeam=\"currentTurnTeam\"\n            :currentPlayer=\"currentTurnTeam == 1 ? team1[team1Index] : team2[team2Index]\"\n            :currentTerm=\"terms[currentTermIndex]\"\n            v-if=\"state=='guessing'\"\n            @termPassed=\"termPassed\"\n            @termGuessed=\"termGuessed\"\n            class=\"termTop\"\n        />\n        <Guessing\n            :currentTurnTeam=\"currentTurnTeam\"\n            :currentPlayer=\"currentTurnTeam == 1 ? team1[team1Index] : team2[team2Index]\"\n            :currentTerm=\"terms[currentTermIndex+1]\"\n            v-if=\"state=='guessing' && terms.length >= (currentTermIndex+2) && false\"\n            class=\"termBottom\"\n        />\n    \n        <EndGuessing\n            :currentTurnTeam=\"currentTurnTeam\"\n            :currentPlayer=\"currentTurnTeam == 1 ? team1[team1Index] : team2[team2Index]\"\n            :points=\"pointsGained\"\n            :scores=\"scores\"\n            v-if=\"state=='endGuessing'\" \n            @turnOver=\"turnOver\"\n        />\n\n        <EndRound\n            :currentRound=\"recentGame.setup.rules.rounds[currentRound]\"\n            :scores=\"scores\"\n            :progress=\"recentGame.progress\"\n            v-if=\"state=='endRound'\" \n            @endRound=\"endRound\"\n        />\n\n        <GameOver\n            :scores=\"scores\"\n            :recentGame=\"recentGame\"\n            v-if=\"state=='gameOver'\" \n        />\n        \n    </div>\n</template>\n<script>\n\nimport StartRound from './StartRound.vue'\nimport StartGuessing from './StartGuessing'\nimport Guessing from './Guessing'\nimport EndGuessing from './EndGuessing'\nimport EndRound from './EndRound'\nimport GameOver from './GameOver'\n\nexport default {\n    props: {\n        recentGame: Object,\n    },\n    data(){\n        return {\n            state: 'startRound',\n\n            team1: [],\n            team2: [],\n            // keep an index of the player who is explaining atm\n            team1Index: 0,\n            team2Index: 0,\n\n            currentTurnTeam: 1, // which team is playing rn?\n            currentTermIndex: 0,\n            pointsGained: 0,\n\n            currentRound: 0, // pantomime or whatever\n\n            terms: [], // this terms array gets reloaded every round\n\n            timeToGuessSetting: 5,\n            timeToGuess: null, // timer \n            timePentaltyAmount: 10,\n\n            scores: {team1: 0, team2: 0} // one point per term\n\n        }\n    },\n    components: {\n        StartRound,\n        StartGuessing,\n        Guessing,\n        EndGuessing,\n        EndRound,\n        GameOver\n    },\n\n    watch: {\n        timeToGuess(){\n            if (this.timeToGuess <= 0) {\n                this.endGuessing()\n            }\n        }\n    },\n\n    methods:{\n        getTermsArray(){\n            this.terms = [] // make it empty first\n            for (let id in this.recentGame.setup.terms){\n                this.terms.push(this.recentGame.setup.terms[id][0])\n            }\n\n        },\n\n        startRound(){\n            this.state = 'startGuessing'\n            this.currentTermIndex = 0 // start with the first term\n            // get the terms array\n            this.getTermsArray()\n            // randomize the terms array\n            this.shuffleArray(this.terms)\n\n        },\n        startGuessing(){\n            this.state = \"guessing\"\n            this.pointsGained = 0\n\n            this.timeToGuess = this.timeToGuessSetting\n\n            \n            // start the timer\n            this.interval = setInterval(() => this.timeToGuess--, 1000)\n        },\n\n        shuffleArray(arr){\n                arr.sort(() => Math.random() - 0.5);\n        },\n\n        timePentalty(team){\n            this.timeToGuess = this.timeToGuess - 10\n        },\n\n        //term returned\n        termPassed(){\n            this.timePentalty()\n            this.terms.push(this.terms[this.currentTermIndex]) // keep the term to play it again\n            this.currentTermIndex ++            \n            // if this was the last term in the terms array, end the guessing\n            if(this.currentTermIndex == this.terms.length) {\n                this.endGuessing()\n            }\n        },\n        termGuessed(){\n            this.pointsGained ++ // reward\n            this.currentTermIndex ++            \n            if(this.currentTermIndex == this.terms.length) {\n                this.endGuessing()\n            }\n        },\n\n        endGuessing(){\n            this.state = \"endGuessing\"\n            clearInterval(this.interval) // stop the timer\n            this.scores[\"team\" + this.currentTurnTeam] = this.scores[\"team\" + this.currentTurnTeam] + this.pointsGained\n            \n            // log the game's new progress\n            let newInfo = {\n                \"round\": this.currentRound,\n                \"team\": this.currentTurnTeam,\n                \"points\": this.pointsGained\n            }\n            this.$emit('addToProgress', newInfo)\n        },\n        \n        // increment the teamIndex so that the next person can play\n        nextPlayersTurn(){\n            if (this.currentTurnTeam - 1) {\n                this.team2Index =  (this.team2Index + 1) % this.team2.length\n            } else {\n                this.team1Index = (this.team1Index + 1) % this.team1.length\n            }\n        },\n\n        nextTeamsTurn(){\n            if(this.currentTurnTeam-1){this.currentTurnTeam=1}\n            else{this.currentTurnTeam=2}\n        },\n\n        turnOver(){\n            this.nextPlayersTurn()\n            this.nextTeamsTurn()\n            // round not over, some terms are not guessed yet\n            if ((this.currentTermIndex ) < this.terms.length) {\n                this.state = 'startGuessing'\n            } \n            // round is over\n            else {\n                this.state = 'endRound'\n            }\n\n        },\n\n        endRound(){\n            // check if there are still rounds to be played\n            while ((this.currentRound + 1) < this.recentGame.setup.rules.rounds.length) {\n                this.currentRound++\n                if (this.recentGame.setup.rules.rounds[this.currentRound].value) {\n                    this.state = 'startRound'\n                    return\n                }\n            }\n            this.gameOver()\n        },\n\n        gameOver(){\n            this.$emit('gameOver') // delete this\n            this.state = 'gameOver'\n        }\n\n    },\n    mounted(){\n        // distribute the teams now\n        for(let id in this.recentGame.setup.playersTeams){\n            let name = this.recentGame.setup.playersTeams[id].name\n            let team = this.recentGame.setup.playersTeams[id].team\n            if (team == 1){this.team1.push(name)}\n            else if (team == 2){this.team2.push(name)}\n            else{console.log('oida')}\n        }\n\n        // the first round should be a selected one\n        for (let i = 0; i < this.recentGame.setup.rules.rounds.length; i++) {\n            if (this.recentGame.setup.rules.rounds[i].value) {\n                this.currentRound = i\n                break\n            }\n        }\n\n    }\n}\n</script>\n\n<style scoped>\n.fade-enter, .fade-leave-to {\n\topacity: 0;\n}\n\n.fade-leave-active {\n\t position: relative;\n}\n\n\n\n</style>"]},"metadata":{},"sourceType":"module"}